/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "GraphClass" CASCADE;

CREATE TABLE "GraphClass" (
  "graphClassName" VARCHAR(255) NOT NULL PRIMARY KEY,
  "directGraph" BOOLEAN NOT NULL DEFAULT '0',
  "acyclicGraph" BOOLEAN NOT NULL DEFAULT '0');

/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "ObjectClass" CASCADE;

CREATE TABLE "ObjectClass" (
  "objectClassName" VARCHAR(255) NOT NULL PRIMARY KEY);

/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "Graph" CASCADE;

CREATE TABLE "Graph" (
  "idGraph" BIGSERIAL NOT NULL PRIMARY KEY,
  "objectName" VARCHAR(255) NOT NULL,
  "viewNumber" BIGINT NOT NULL,
  "nodeCount" INTEGER NOT NULL,
  "edgeCount" INTEGER NOT NULL,
  "cumulativeMass" INTEGER NOT NULL,
  "DAGCost" DOUBLE PRECISION NOT NULL,
  "fileOffset" INTEGER NOT NULL,
  "MaxTSVDimension" INTEGER NOT NULL,
  "totalTSVSum" DOUBLE PRECISION NOT NULL,
  "shape_xMax" DOUBLE PRECISION NOT NULL,
  "shape_xMin" DOUBLE PRECISION NOT NULL,
  "shape_yMax" DOUBLE PRECISION NOT NULL,
  "shape_yMin" DOUBLE PRECISION NOT NULL,
  "shape_Height" DOUBLE PRECISION NOT NULL,
  "shape_Width" DOUBLE PRECISION NOT NULL,
  "XMLSignature" TEXT NOT NULL,
  "refGraphClass" VARCHAR(255) NOT NULL,
  "refObjectClass" VARCHAR(255) NOT NULL);

CREATE INDEX "index_Graph_graphClass"
  ON "Graph" USING BTREE ("refGraphClass");

CREATE INDEX "index_Graph_objectClass"
  ON "Graph" USING BTREE ("refObjectClass");

CREATE UNIQUE INDEX "index_Graph_objectName"
  ON "Graph" USING BTREE ("objectName");

ALTER TABLE "Graph"
  ADD CONSTRAINT "refGraphClass_fk"
    FOREIGN KEY ("refGraphClass")
    REFERENCES "GraphClass" ("graphClassName")
    ON DELETE CASCADE
    INITIALLY DEFERRED,
  ADD CONSTRAINT "refObjectClass_fk"
    FOREIGN KEY ("refObjectClass")
    REFERENCES "ObjectClass" ("objectClassName")
    ON DELETE CASCADE
    INITIALLY DEFERRED;

/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "Node" CASCADE;

CREATE TABLE "Node" (
  "idNode" BIGSERIAL NOT NULL PRIMARY KEY,
  "index" INTEGER NOT NULL DEFAULT '-1',
  "label" VARCHAR(255) NOT NULL DEFAULT '-1',
  "level" INTEGER NOT NULL DEFAULT '-1',
  "mass" INTEGER NOT NULL DEFAULT '-1',
  "type" INTEGER NOT NULL DEFAULT '-1',
  "role" INTEGER NOT NULL DEFAULT 0,
  "pointCount" INTEGER NOT NULL DEFAULT '-1',
  "contourLength1" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "contourLength2" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "subtreeCost" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "tsvNorm" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "refGraph" BIGINT NOT NULL);

CREATE INDEX "Node_RefGraph"
  ON "Node" USING BTREE ("refGraph");

ALTER TABLE "Node"
  ADD CONSTRAINT "refGraph_fk"
    FOREIGN KEY ("refGraph")
    REFERENCES "Graph" ("idGraph")
    ON DELETE CASCADE
    INITIALLY DEFERRED;

/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "Edge" CASCADE;

CREATE TABLE "Edge" (
  "idEdge" BIGSERIAL NOT NULL PRIMARY KEY,
  "weight" INTEGER NOT NULL DEFAULT '-1',
  "sourceDFSIndex" INTEGER NOT NULL DEFAULT '-1',
  "targetDFSIndex" INTEGER NOT NULL DEFAULT '-1',
  "source" BIGINT NOT NULL,
  "target" BIGINT NOT NULL,
  "refGraph" BIGINT NOT NULL);

CREATE INDEX "index_Edge_source"
  ON "Edge" USING BTREE ("source");

CREATE INDEX "index_Edge_target"
  ON "Edge" USING BTREE ("target");

CREATE UNIQUE INDEX "index_Edge_link"
  ON "Edge" USING BTREE (
    "source",
    "target");

CREATE INDEX "index_Edge_refGraph"
  ON "Edge" USING BTREE ("refGraph");

ALTER TABLE "Edge"
  ADD CONSTRAINT "source_fk"
    FOREIGN KEY ("source")
    REFERENCES "Node" ("idNode")
    ON DELETE CASCADE
    INITIALLY DEFERRED,
  ADD CONSTRAINT "target_fk"
    FOREIGN KEY ("target")
    REFERENCES "Node" ("idNode")
    ON DELETE CASCADE
    INITIALLY DEFERRED,
  ADD CONSTRAINT "refGraph_fk"
    FOREIGN KEY ("refGraph")
    REFERENCES "Graph" ("idGraph")
    ON DELETE CASCADE
    INITIALLY DEFERRED;

/* This file was generated by ODB, object-relational mapping (ORM)
 * compiler for C++.
 */

DROP TABLE IF EXISTS "Point" CASCADE;

CREATE TABLE "Point" (
  "idPoint" BIGSERIAL NOT NULL PRIMARY KEY,
  "xCoord" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "yCoord" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "radius" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "speed" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "dr_ds" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "dr" DOUBLE PRECISION NOT NULL DEFAULT '-1',
  "type" INTEGER NOT NULL DEFAULT '-1',
  "direction" INTEGER NOT NULL DEFAULT -1,
  "refGraph" BIGINT NOT NULL,
  "refNode" BIGINT NOT NULL);

CREATE INDEX "index_Point_refNode"
  ON "Point" USING BTREE ("refNode");

CREATE INDEX "index_Point_refGraph"
  ON "Point" USING BTREE ("refGraph");

CREATE INDEX "index_Point_region2D"
  ON "Point" USING BTREE (
    "xCoord",
    "yCoord");

ALTER TABLE "Point"
  ADD CONSTRAINT "refGraph_fk"
    FOREIGN KEY ("refGraph")
    REFERENCES "Graph" ("idGraph")
    ON DELETE CASCADE
    INITIALLY DEFERRED,
  ADD CONSTRAINT "refNode_fk"
    FOREIGN KEY ("refNode")
    REFERENCES "Node" ("idNode")
    ON DELETE CASCADE
    INITIALLY DEFERRED;

-- GET TABLE STATE FOR ALL TABLES 

CREATE OR REPLACE FUNCTION public.count_rows(
    _schema text,
    _tablename text)
  RETURNS integer AS
$BODY$
DECLARE
rec integer;
BEGIN
EXECUTE 'SELECT count(*) FROM "' || $1 || '"."' || $2 || '"' INTO rec;
RETURN rec;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.count_rows(text, text)
  OWNER TO postgres;

CREATE OR REPLACE FUNCTION public.gettablestate()
  RETURNS TABLE(_schema text, _tname text, _count integer) AS
$BODY$
BEGIN

   RETURN QUERY
   
   SELECT table_schema::text, table_name::text, count_rows(table_schema, table_name)
FROM information_schema.tables 
WHERE table_schema not in ('pg_catalog', 'information_schema') and table_type='BASE TABLE'
order by 3 desc;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION public.gettablestate()
  OWNER TO postgres;
  
  
  
ï»¿/* This view is used to perform the Machine Learning approach.
 * Created by Jonathan DEKHTIAR
 */

CREATE VIEW "learning_data" AS
  SELECT
	g."refObjectClass", 
	g."cumulativeMass", 
	g."DAGCost",
	g."MaxTSVDimension", 
	g."totalTSVSum", 
	g."shape_xMax", 
	g."shape_xMin", 
	g."shape_yMax", 
	g."shape_yMin", 
	g."shape_Height", 
	g."shape_Width",
	n."nodeCount",
	e."edgeCount",
	p."pointCount",
	n."avg_pointCount" as "avg_pointPerNode", 
	n."avg_level", 
	n."avg_mass", 
	n."avg_type" as "avg_NodeType", 
	n."avg_role", 
	n."avg_contourLength1", 
	n."avg_contourLength2", 
	n."avg_subtreeCost", 
	n."avg_tsvNorm",
	p."avg_xCoord", 
	p."avg_yCoord", 
	p."avg_radius", 
	p."avg_speed", 
	p."avg_dr_ds", 
	p."avg_dr", 
	p."avg_type" as "avg_PointType", 
	p."avg_direction"
FROM 
	"Graph" as g
LEFT JOIN
	(SELECT 
		count(*) as "nodeCount" , 
		avg("level") as "avg_level", 
		avg("mass") as "avg_mass", 
		avg("type") as "avg_type", 
		avg("role") as "avg_role", 
		avg("pointCount") as "avg_pointCount", 
		avg("contourLength1") as "avg_contourLength1", 
		avg("contourLength2") as "avg_contourLength2", 
		avg("subtreeCost") as "avg_subtreeCost", 
		avg("tsvNorm") as "avg_tsvNorm",
		"refGraph"
	FROM "Node"
	GROUP BY "refGraph") as n
ON g."idGraph" = n."refGraph"

LEFT JOIN
	(SELECT 
		count(*) as "edgeCount",
		"refGraph"
	FROM "Edge" 
	GROUP BY  "refGraph") as e
ON g."idGraph" = e."refGraph"

LEFT JOIN
	(SELECT 
		count(*) as "pointCount",
		avg("xCoord") as "avg_xCoord", 
		avg("yCoord") as "avg_yCoord", 
		avg("radius") as "avg_radius", 
		avg("speed") as "avg_speed", 
		avg("dr_ds") as "avg_dr_ds", 
		avg("dr")as "avg_dr", 
		avg("type") as "avg_type", 
		avg("direction") as "avg_direction", 
		"refGraph" 
	FROM "Point" 
	GROUP BY "refGraph") as p
ON g."idGraph" = p."refGraph"

ORDER BY "idGraph";

